---
title: "Chapter 2"
author: "Kevin J. Coyle"
format: gfm
editor: visual
---

```{r}
#| label: setup
#| include: false

store.num <- factor(c(3, 14, 21, 32, 54))  # store id
store.rev <- c(543, 654, 345, 678, 234)  # store revenue, $1000
store.visits <- c(45, 78, 32, 56, 34)  # visits, 1000s
store.manager <- c("Annie", "Bert", "Carla", "Dave", "Ella")
store.df <- data.frame(store.num, store.rev, store.visits,
                        store.manager, stringsAsFactors=F)
```

1.  Create a text vector called `Months` with names of the 12 months of the year.

```{r}
(Months <- c("January", "February", "March", "April", "May",
            "June", "July", "August", "September", "October",
            "November, December"))
```

2.  Create a numeric vector `Summer`, with Calendar month index positions for the summer months (inclusive, with 4 elements in all). \[*Summer has only 3 months. â€”KJC*\]

```{r}
(Summer <- 6:8)
```

3.  Use vector indexing to extract the text values of `Months`, indexed by `Summer`.

```{r}
Months[Summer]
```

4.  Multiply `Summer` by 3. What are the values of `Months`, when indexed by `Summer` multiplied by 3? Why do you get that answer?

```{r}
Months[Summer * 3]
```

You get `NA`s because the index exceeds the vector bounds.

5.  What is the mean (average) summer month, as an integer value? Which value of `Months` corresponds to it? Why do you get that answer?

```{r}
mean(Summer)
Months[mean(Summer)]
```

"July" is the seventh item of the `Months` vector.

6.  Use the `floor()` and `ceiling` functions to return the upper and lower limits of `Months` for the average `Summer` month.

```{r}
Months[floor(mean(Summer))]
Months[ceiling(mean(Summer))]
```

7.  Using the `store.df` data from Sec. 2.5, how many visits did Bert's store have?

```{r}
store.df[store.df$store.manager == "Bert", ]$store.visits
```

8.  It is easy to make mistakes in indexing. How can you confirm that the previous answer is actually from Bert's store? Show this with a command that produces no more than one row of console output.

```{r}
store.df[store.df$store.manager == "Bert", ]
```

9.  Write a function called `PieArea` that takes the length of a slice of pie and returns the area of a whole pie.

```{r}
PieArea <- function(r) { return(pi * r^2) }
```

10. What is `PieArea` for slices with lengths 4.0, 4.5, 5.0, and 6.0?

```{r}
PieArea(c(4.0, 4.5, 5.0, 6.0))
```

11. Rewrite the previous command as one line of code, without using the `PieArea` function. Which of the two solutions do you prefer, and why?

```{r}
pi * c(4.0, 4.5, 5.0, 6.0)^2
```

I prefer the first solution, because the computation is clearer and it is reusable.
